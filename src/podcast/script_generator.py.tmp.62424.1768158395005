import logging
import json
from typing import List, Dict, Any
from dataclasses import dataclass

from crewai import LLM
from src.document_processing.doc_processor import DocumentProcessor

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


@dataclass
class PodcastScript:
    """Represents a podcast script with metadata"""
    script: List[Dict[str, str]]
    source_document: str
    total_lines: int
    estimated_duration: str
    
    def get_speaker_lines(self, speaker: str) -> List[str]:
        return [item[speaker] for item in self.script if speaker in item]
    
    def to_json(self) -> str:
        return json.dumps({
            'script': self.script,
            'metadata': {
                'source_document': self.source_document,
                'total_lines': self.total_lines,
                'estimated_duration': self.estimated_duration
            }
        }, indent=2)


class PodcastScriptGenerator:
    def __init__(self, openai_api_key: str, model_name: str = "gpt-4o-mini"):
        self.llm = LLM(
            model=f"openai/{model_name}",
            temperature=0.9,  # Higher temperature for more creative, natural dialogue
            max_tokens=4000
        )
        self.doc_processor = DocumentProcessor()
        logger.info(f"Podcast script generator initialized with {model_name}")
    
    def generate_script_from_document(
        self,
        document_path: str,
        podcast_style: str = "conversational",
        target_duration: str = "10 minutes"
    ) -> PodcastScript:

        logger.info(f"Generating podcast script from: {document_path}")
        
        chunks = self.doc_processor.process_document(document_path)
        if not chunks:
            raise ValueError("No content extracted from document")
        
        document_content = "\n\n".join([chunk.content for chunk in chunks])
        source_name = chunks[0].source_file
        script_data = self._generate_conversation_script(
            document_content, 
            podcast_style, 
            target_duration
        )
        
        podcast_script = PodcastScript(
            script=script_data['script'],
            source_document=source_name,
            total_lines=len(script_data['script']),
            estimated_duration=target_duration
        )
        
        logger.info(f"Generated script with {podcast_script.total_lines} lines")
        return podcast_script
    
    def generate_script_from_text(
        self,
        text_content: str,
        source_name: str = "Text Input",
        podcast_style: str = "conversational",
        target_duration: str = "10 minutes"
    ) -> PodcastScript:

        logger.info("Generating podcast script from text input")
        
        script_data = self._generate_conversation_script(
            text_content,
            podcast_style,
            target_duration
        )
        
        podcast_script = PodcastScript(
            script=script_data['script'],
            source_document=source_name,
            total_lines=len(script_data['script']),
            estimated_duration=target_duration
        )
        
        logger.info(f"Generated script with {podcast_script.total_lines} lines")
        return podcast_script
    
    def generate_script_from_website(
        self,
        website_chunks: List[Any],
        source_url: str,
        podcast_style: str = "conversational",
        target_duration: str = "10 minutes"
    ) -> PodcastScript:

        logger.info(f"Generating podcast script from website: {source_url}")
        
        if not website_chunks:
            raise ValueError("No website content provided")
        
        website_content = "\n\n".join([chunk.content for chunk in website_chunks])
        script_data = self._generate_conversation_script(
            website_content,
            podcast_style,
            target_duration
        )
        
        podcast_script = PodcastScript(
            script=script_data['script'],
            source_document=source_url,
            total_lines=len(script_data['script']),
            estimated_duration=target_duration
        )
        
        logger.info(f"Generated website script with {podcast_script.total_lines} lines")
        return podcast_script
    
    def _generate_conversation_script(
        self,
        document_content: str,
        podcast_style: str,
        target_duration: str
    ) -> Dict[str, Any]:

        style_prompts = {
            "conversational": """Create an EXTREMELY natural, spontaneous conversation between two real people discussing the document.
Make it sound like actual humans talking - use:
- Natural speech patterns: "um", "you know", "like", "I mean", "actually", "basically", "kind of", "sort of"
- Enthusiastic reactions: "Oh wow!", "That's so interesting!", "Right!", "Exactly!", "No way!", "Really?"
- Incomplete thoughts and sentences
- Brief interruptions and interjections
- Laughter: "[chuckles]", "[laughs]"
- Building on each other's ideas mid-sentence
- Casual language, contractions (don't, can't, we're)
- Personal reactions and mini-stories
- Thinking out loud: "Hmm...", "Let me think...", "You know what's interesting..."
Make it feel like listening to two friends chatting over coffee, NOT a scripted presentation.""",
            "educational": "Create a natural educational discussion with authentic reactions, occasional 'aha!' moments, and genuine curiosity. Use casual language while explaining concepts clearly.",
            "interview": "Create a natural interview where the interviewer shows genuine interest, reacts authentically, and the interviewee explains things conversationally with real-world examples.",
            "debate": "Create an engaging discussion with authentic disagreements, 'I see your point, but...', and natural back-and-forth with real human reactions."
        }
        
        style_instruction = style_prompts.get(podcast_style, style_prompts["conversational"])
    
        duration_guidelines = {
            "5 minutes": "Keep the conversation concise, focusing on 3-4 main points with brief explanations.",
            "10 minutes": "Cover the key topics thoroughly with good explanations and examples.",
            "15 minutes": "Provide comprehensive coverage with detailed discussions and multiple examples.",
            "20 minutes": "Create an in-depth exploration with extensive analysis and supporting details."
        }
        
        duration_guide = duration_guidelines.get(target_duration, duration_guidelines["10 minutes"])
        
        prompt = f"""Using the following document, create a podcast script for two speakers: 'Speaker 1' and 'Speaker 2'. 

STYLE GUIDELINES:
{style_instruction}

DURATION GUIDELINES:
{duration_guide}

CONVERSATION RULES FOR ULTRA-NATURAL DIALOGUE:
1. Vary turn length: Sometimes 1 sentence, sometimes 3-4. Keep it unpredictable like real conversation
2. Use LOTS of natural fillers: "um", "uh", "like", "you know", "I mean", "actually", "so"
3. Show genuine reactions: "Whoa!", "Oh interesting!", "Huh!", "Really?", "No way!", "Right!"
4. Include laughter and chuckles: "[laughs]", "[chuckles]", "[both laugh]"
5. Let speakers interrupt occasionally: "Yeah, and-", "Oh! That reminds me-"
6. Use incomplete sentences and trailing off: "And so like...", "It's kind of..."
7. Build on each other's points: "Exactly! And...", "Oh that's such a good point about..."
8. Think out loud: "Hmm... I wonder if...", "Let me think about that..."
9. Use contractions everywhere: don't, can't, won't, it's, that's, we're
10. Add personal touches: "I love how...", "What I find fascinating is...", "This makes me think of..."
11. Avoid overly formal or academic language - keep it casual and relatable
12. Make mistakes and self-correct: "So basically, or wait, actually..."
CRITICAL: This should sound like two friends excitedly discussing something they find interesting, NOT like reading from a script!

RESPONSE FORMAT:
Respond with a valid JSON object containing a 'script' array. Each array element should be an object with either 'Speaker 1' or 'Speaker 2' as the key and their dialogue as the value.

Example of NATURAL dialogue (notice the casual tone, fillers, reactions):
{{
  "script": [
    {{"Speaker 1": "Okay, so, um, we're talking about this really fascinating paper today and honestly? I'm kind of blown away by some of the stuff in here."}},
    {{"Speaker 2": "Right?! [laughs] Like, when I first read it I was like, wait, this actually makes so much sense. You know what really got me though?"}},
    {{"Speaker 1": "What's that?"}},
    {{"Speaker 2": "Well, okay, so basically they're saying that - and this is the cool part - um..."}},
    {{"Speaker 1": "Oh! I think I know what you're gonna say-"}},
    {{"Speaker 2": "Exactly! [chuckles] It's like, the whole thing about how students struggle with research, and I mean, we've all been there, right?"}}
  ]
}}

IMPORTANT: Your dialogue should be EVEN MORE natural than this example. Really lean into the conversational fillers and authentic reactions!

DOCUMENT CONTENT:
{document_content[:8000]}  

Generate an engaging {target_duration} podcast script now:"""
        
        try:
            response = self.llm.call(prompt)
            script_data = json.loads(response)
            
            if 'script' not in script_data or not isinstance(script_data['script'], list):
                raise ValueError("Invalid script format returned by LLM")
            
            validated_script = self._validate_and_clean_script(script_data['script'])
            
            return {'script': validated_script}
            
        except json.JSONDecodeError as e:
            logger.error(f"Failed to parse LLM response as JSON: {e}")
            response_clean = response.strip()
            if response_clean.startswith('```json'):
                response_clean = response_clean[7:-3]
            elif response_clean.startswith('```'):
                response_clean = response_clean[3:-3]
            
            try:
                script_data = json.loads(response_clean)
                validated_script = self._validate_and_clean_script(script_data['script'])
                return {'script': validated_script}
            except:
                raise ValueError(f"Could not parse LLM response as valid JSON: {response}")
        
        except Exception as e:
            logger.error(f"Error generating script: {str(e)}")
            raise
    
    def _validate_and_clean_script(self, script: List[Dict[str, str]]) -> List[Dict[str, str]]:
        cleaned_script = []
        expected_speaker = "Speaker 1"
        for item in script:
            if not isinstance(item, dict) or len(item) != 1:
                continue
            
            speaker, dialogue = next(iter(item.items()))
            speaker = speaker.strip()

            if speaker not in ["Speaker 1", "Speaker 2"]:
                if "1" in speaker or "one" in speaker.lower():
                    speaker = "Speaker 1"
                elif "2" in speaker or "two" in speaker.lower():
                    speaker = "Speaker 2"
                else:
                    speaker = expected_speaker
            
            dialogue = dialogue.strip()
            if not dialogue:
                continue
            if not dialogue.endswith(('.', '!', '?')):
                dialogue += '.'
            
            cleaned_script.append({speaker: dialogue})

            expected_speaker = "Speaker 2" if expected_speaker == "Speaker 1" else "Speaker 1"
        
        if len(cleaned_script) < 2:
            raise ValueError("Generated script is too short or invalid")
        
        return cleaned_script


if __name__ == "__main__":
    import os
    
    openai_key = os.getenv("OPENAI_API_KEY")
    if not openai_key:
        print("Please set OPENAI_API_KEY environment variable")
        exit(1)
    
    generator = PodcastScriptGenerator(openai_key)
    
    try:
        sample_text = """
        Artificial Intelligence (AI) represents one of the most significant technological advances of our time. 
        Machine learning, a subset of AI, enables computers to learn and improve from experience without being 
        explicitly programmed for every task. Deep learning, which uses neural networks with multiple layers, 
        has revolutionized fields like computer vision, natural language processing, and speech recognition. 
        The applications are vast, from autonomous vehicles to medical diagnosis, and the potential impact on 
        society is profound. However, ethical considerations around AI development, including bias, privacy, 
        and job displacement, remain important challenges that need to be addressed as the technology continues to evolve.
        """
        
        script = generator.generate_script_from_text(
            sample_text,
            source_name="AI Overview",
            podcast_style="conversational",
            target_duration="5 minutes"
        )
        
        print("Generated Podcast Script:")
        print("=" * 50)
        print(f"Source: {script.source_document}")
        print(f"Lines: {script.total_lines}")
        print(f"Duration: {script.estimated_duration}")
        print("\nScript:")
        
        for i, line_dict in enumerate(script.script, 1):
            speaker, dialogue = next(iter(line_dict.items()))
            print(f"{i}. {speaker}: {dialogue}\n")
        
        # Save to file
        with open("sample_podcast_script.json", "w") as f:
            f.write(script.to_json())
        print("Script saved to sample_podcast_script.json")
        
    except Exception as e:
        print(f"Error: {e}")